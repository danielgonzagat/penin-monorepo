#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
darwinctl — orquestra spawn/rollback e executa hooks declarativos.
Patch Avançado Darwin v2 com sistema completo de hooks.

Eventos e hooks:
  hooks.d/pre_spawn/*.sh|*.py
  hooks.d/post_spawn/*.sh|*.py
  hooks.d/pre_rollback/*.sh|*.py
  hooks.d/post_rollback/*.sh|*.py

Env para hooks:
  EVENT, NEURON_ID, REASON, SNAPSHOT, MODEL_SYMLINK, TIMESTAMP
"""
import os, sys, time, json, subprocess, argparse
from pathlib import Path
from datetime import datetime
from typing import Dict, Any

ROOT = Path("/opt/ia3-neurogenesis").resolve()
HOOKS = ROOT / "darwinctl" / "hooks.d"
MODELS_DIR = Path("/root/models")
SYMLINK = Path("/root/current_model")
LOG_FILE = Path("/root/ia3_darwin_hooks.log")

# ═══════════════════════════════════════════════════════════════════════════════
# SISTEMA DE HOOKS AVANÇADO
# ═══════════════════════════════════════════════════════════════════════════════

def _run_hooks(event: str, env: dict) -> Dict[str, Any]:
    """Executa hooks de um evento específico em ordem"""
    folder = HOOKS / event
    results = {"executed": [], "failed": [], "total": 0}
    
    if not folder.exists():
        print(f"📁 Pasta de hooks não encontrada: {folder}")
        return results
    
    # Executar scripts em ordem alfabética
    hooks = sorted([h for h in folder.glob("*") if os.access(h, os.X_OK)])
    results["total"] = len(hooks)
    
    if not hooks:
        print(f"📝 Nenhum hook executável encontrado em {event}")
        return results
    
    print(f"🔧 Executando {len(hooks)} hooks para evento '{event}':")
    
    for script in hooks:
        try:
            print(f"   ▶️ {script.name}...")
            
            # Preparar ambiente
            hook_env = {**os.environ, **env}
            
            # Executar hook
            start_time = time.time()
            result = subprocess.run(
                [str(script)], 
                check=False, 
                env=hook_env,
                capture_output=True,
                text=True,
                timeout=30  # Timeout de 30 segundos por hook
            )
            duration = time.time() - start_time
            
            if result.returncode == 0:
                print(f"      ✅ Sucesso ({duration:.2f}s)")
                results["executed"].append({
                    "script": script.name,
                    "duration": duration,
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip()
                })
            else:
                print(f"      ❌ Falha (código {result.returncode}, {duration:.2f}s)")
                results["failed"].append({
                    "script": script.name,
                    "returncode": result.returncode,
                    "duration": duration,
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip()
                })
                
                # Log erro detalhado
                _log_hook_error(event, script.name, result.returncode, result.stderr)
        
        except subprocess.TimeoutExpired:
            print(f"      ⏰ Timeout ({script.name})")
            results["failed"].append({
                "script": script.name,
                "error": "timeout",
                "duration": 30.0
            })
        except Exception as e:
            print(f"      💥 Exceção ({script.name}): {e}")
            results["failed"].append({
                "script": script.name,
                "error": str(e),
                "duration": 0.0
            })
    
    return results

def _log_hook_error(event: str, script: str, code: int, stderr: str):
    """Log detalhado de erros de hooks"""
    LOG_FILE.parent.mkdir(exist_ok=True)
    with open(LOG_FILE, "a") as f:
        f.write(f"{datetime.utcnow().isoformat()}Z [ERROR] {event}/{script} "
                f"code={code} stderr={stderr[:200]}\n")

def _timestamp():
    return datetime.utcnow().isoformat() + "Z"

# ═══════════════════════════════════════════════════════════════════════════════
# COMANDOS PRINCIPAIS
# ═══════════════════════════════════════════════════════════════════════════════

def spawn(neuron_id: str, reason: str = "evolution_pass"):
    """
    Spawn um neurônio IA³ com sistema completo de hooks
    """
    print(f"\n🐣 SPAWN NEURÔNIO IA³")
    print(f"   ID: {neuron_id}")
    print(f"   Razão: {reason}")
    
    # Preparar ambiente para hooks
    env = {
        "EVENT": "spawn",
        "NEURON_ID": neuron_id,
        "TIMESTAMP": _timestamp(),
        "REASON": reason,
        "SNAPSHOT": os.getenv("SNAPSHOT", ""),
        "IA3_MODE": "advanced_v2"
    }
    
    # PRE-SPAWN hooks
    print(f"\n📋 Executando PRE-SPAWN hooks...")
    pre_results = _run_hooks("pre_spawn", env)
    
    # Evento principal de spawn
    spawn_data = {
        "event": "neuron_spawn",
        "neuron_id": neuron_id,
        "reason": reason,
        "timestamp": env["TIMESTAMP"],
        "pre_hooks": pre_results
    }
    
    print(f"\n🧬 Executando SPAWN principal...")
    
    # POST-SPAWN hooks (incluindo treinamento e avaliação IA³)
    print(f"\n🔬 Executando POST-SPAWN hooks...")
    post_results = _run_hooks("post_spawn", env)
    
    # Resultado final
    spawn_data["post_hooks"] = post_results
    spawn_data["success"] = len(post_results["failed"]) == 0
    
    print(f"\n📄 SPAWN LOG:")
    print(json.dumps(spawn_data, indent=2))
    
    # Log para arquivo
    with open(LOG_FILE, "a") as f:
        f.write(json.dumps(spawn_data, ensure_ascii=False) + "\n")
    
    return spawn_data["success"]

def rollback(reason: str = "manual"):
    """
    Rollback com hooks e symlink management
    """
    print(f"\n🔄 ROLLBACK IA³")
    print(f"   Razão: {reason}")
    
    # Preparar ambiente
    env = {
        "EVENT": "rollback",
        "REASON": reason,
        "TIMESTAMP": _timestamp(),
        "MODEL_SYMLINK": str(SYMLINK),
        "IA3_MODE": "advanced_v2"
    }
    
    # PRE-ROLLBACK hooks
    print(f"\n📋 Executando PRE-ROLLBACK hooks...")
    pre_results = _run_hooks("pre_rollback", env)
    
    # Rollback principal: apontar symlink para champion
    rollback_success = False
    try:
        champion = MODELS_DIR / "final_stable.json"
        
        if not champion.exists():
            print(f"⚠️ Champion não encontrado: {champion}")
            # Criar champion dummy se não existir
            MODELS_DIR.mkdir(exist_ok=True)
            with open(champion, "w") as f:
                json.dump({"model": "stable_champion", "timestamp": _timestamp()}, f)
        
        if SYMLINK.exists() or SYMLINK.is_symlink():
            SYMLINK.unlink()
        
        SYMLINK.symlink_to(champion)
        rollback_success = True
        env["ROLLBACK_SUCCESS"] = "1"
        env["CHAMPION_PATH"] = str(champion)
        print(f"   ✅ Symlink atualizado: {SYMLINK} → {champion}")
        
    except Exception as e:
        env["ROLLBACK_SUCCESS"] = "0"
        env["ERROR"] = str(e)
        print(f"   ❌ Erro no rollback: {e}")

    # POST-ROLLBACK hooks
    print(f"\n🔄 Executando POST-ROLLBACK hooks...")
    post_results = _run_hooks("post_rollback", env)
    
    # Resultado final
    rollback_data = {
        "event": "rollback",
        "reason": reason,
        "timestamp": env["TIMESTAMP"],
        "success": rollback_success,
        "pre_hooks": pre_results,
        "post_hooks": post_results
    }
    
    print(f"\n📄 ROLLBACK LOG:")
    print(json.dumps(rollback_data, indent=2))
    
    # Log para arquivo
    with open(LOG_FILE, "a") as f:
        f.write(json.dumps(rollback_data, ensure_ascii=False) + "\n")
    
    return rollback_success

def status():
    """Mostra status do sistema de hooks"""
    print(f"\n📊 STATUS SISTEMA DE HOOKS IA³")
    print(f"   Root: {ROOT}")
    print(f"   Hooks dir: {HOOKS}")
    print(f"   Log file: {LOG_FILE}")
    
    # Verificar estrutura de hooks
    for event_type in ["pre_spawn", "post_spawn", "pre_rollback", "post_rollback"]:
        event_dir = HOOKS / event_type
        if event_dir.exists():
            hooks = list(event_dir.glob("*"))
            executable_hooks = [h for h in hooks if os.access(h, os.X_OK)]
            print(f"\n📁 {event_type}:")
            print(f"   Total: {len(hooks)} arquivos")
            print(f"   Executáveis: {len(executable_hooks)}")
            
            for hook in executable_hooks:
                print(f"   ✅ {hook.name}")
        else:
            print(f"\n📁 {event_type}: ❌ Não existe")
    
    # Últimos logs
    if LOG_FILE.exists():
        print(f"\n📜 Últimos hooks executados:")
        try:
            with open(LOG_FILE, "r") as f:
                lines = f.readlines()[-5:]
            for line in lines:
                try:
                    log_data = json.loads(line.strip())
                    event = log_data.get("event", "unknown")
                    ts = log_data.get("timestamp", "unknown")[11:19]  # HH:MM:SS
                    success = "✅" if log_data.get("success", False) else "❌"
                    print(f"   {ts} {success} {event}")
                except:
                    print(f"   {line.strip()[:80]}")
        except Exception as e:
            print(f"   ⚠️ Erro ao ler log: {e}")

def create_example_hooks():
    """Cria hooks de exemplo para demonstração"""
    print(f"🔧 Criando hooks de exemplo...")
    
    # Garantir que diretórios existem
    for event_type in ["pre_spawn", "post_spawn", "pre_rollback", "post_rollback"]:
        (HOOKS / event_type).mkdir(parents=True, exist_ok=True)
    
    # Hook exemplo: log post-spawn
    post_spawn_log = HOOKS / "post_spawn" / "20-log-neuron.sh"
    with open(post_spawn_log, "w") as f:
        f.write("""#!/usr/bin/env bash
set -euo pipefail
echo "[post_spawn] id=$NEURON_ID reason=$REASON ts=$TIMESTAMP" >> /root/ia3_darwin_hooks.log
echo "✅ Neurônio $NEURON_ID logado com sucesso"
""")
    os.chmod(post_spawn_log, 0o755)
    
    # Hook exemplo: avaliação IA³ post-spawn
    post_spawn_eval = HOOKS / "post_spawn" / "30-evaluate-ia3.py"
    with open(post_spawn_eval, "w") as f:
        f.write("""#!/usr/bin/env python3
import os, json, sys, time
sys.path.append("/opt/ia3-neurogenesis")

try:
    from neurogenesis.ia3_neurogenesis import IA3NeuronAgent
    
    neuron_id = os.getenv("NEURON_ID", "unknown")
    print(f"🔬 Avaliando neurônio {neuron_id}...")
    
    agent = IA3NeuronAgent(
        in_dim=16, 
        hidden_dim=8, 
        out_dim=16,
        metrics_port=int(os.getenv("IA3_METRICS_PORT", "9091"))
    )
    
    # Executar rodada IA³
    report = agent.round(seed=int(time.time()) % 10000)
    
    # Log resultado
    record = {
        "event": "neuron_evaluation", 
        "neuron_id": neuron_id, 
        "report": {
            "adaptive_gain": report.adaptive_gain,
            "alpha_shift": report.alpha_shift,
            "improved": report.improved,
            "structure_grew": report.structure_grew,
            "passes": report.passes,
            "consciousness_score": report.consciousness_score
        }
    }
    
    print(json.dumps(record, indent=2))
    
    # Critério DARWIN: neurônio deve provar IA³-like
    if not report.passes:
        print(f"❌ Neurônio {neuron_id} FALHOU na prova IA³")
        sys.exit(3)  # Código especial para falha IA³
    else:
        print(f"✅ Neurônio {neuron_id} APROVADO na prova IA³")

except Exception as e:
    print(f"💥 Erro na avaliação: {e}")
    sys.exit(1)
""")
    os.chmod(post_spawn_eval, 0o755)
    
    # Hook exemplo: log post-rollback
    post_rollback_log = HOOKS / "post_rollback" / "10-notify.sh"
    with open(post_rollback_log, "w") as f:
        f.write("""#!/usr/bin/env bash
echo "[post_rollback] reason=$REASON ts=$TIMESTAMP success=${ROLLBACK_SUCCESS:-0}" >> /root/ia3_darwin_hooks.log
echo "✅ Rollback notificado: $REASON"
""")
    os.chmod(post_rollback_log, 0o755)
    
    print(f"✅ Hooks de exemplo criados")

# ═══════════════════════════════════════════════════════════════════════════════
# COMANDOS PRINCIPAIS
# ═══════════════════════════════════════════════════════════════════════════════

def main():
    parser = argparse.ArgumentParser(
        description="🧬 Darwin Control CLI - Sistema IA³ Avançado v2",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Comandos disponíveis')
    
    # Spawn
    spawn_parser = subparsers.add_parser('spawn', help='Spawn neurônio IA³')
    spawn_parser.add_argument('neuron_id', nargs='?', 
                            default=f"neuron_{int(time.time())}", 
                            help='ID do neurônio')
    spawn_parser.add_argument('--reason', default='evolution_pass',
                            help='Razão do spawn')
    
    # Rollback
    rollback_parser = subparsers.add_parser('rollback', help='Rollback sistema')
    rollback_parser.add_argument('--reason', default='manual',
                               help='Razão do rollback')
    
    # Status
    subparsers.add_parser('status', help='Status do sistema de hooks')
    
    # Create hooks
    subparsers.add_parser('create-hooks', help='Criar hooks de exemplo')
    
    # Test
    test_parser = subparsers.add_parser('test', help='Testar sistema completo')
    test_parser.add_argument('--cycles', type=int, default=3,
                           help='Número de ciclos de teste')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    try:
        if args.command == 'spawn':
            success = spawn(args.neuron_id, args.reason)
            sys.exit(0 if success else 1)
        
        elif args.command == 'rollback':
            success = rollback(args.reason)
            sys.exit(0 if success else 1)
        
        elif args.command == 'status':
            status()
        
        elif args.command == 'create-hooks':
            create_example_hooks()
        
        elif args.command == 'test':
            test_complete_system(args.cycles)
        
    except KeyboardInterrupt:
        print("\n🛑 Comando interrompido pelo usuário")
        sys.exit(1)
    except Exception as e:
        print(f"💥 Erro: {e}")
        sys.exit(1)

def test_complete_system(cycles: int = 3):
    """Teste completo do sistema IA³ com múltiplos ciclos"""
    print(f"\n🧪 TESTE COMPLETO SISTEMA IA³ AVANÇADO")
    print(f"   Ciclos: {cycles}")
    print("="*60)
    
    # Criar hooks se não existirem
    create_example_hooks()
    
    success_count = 0
    fail_count = 0
    
    for cycle in range(1, cycles + 1):
        print(f"\n🔄 CICLO {cycle}/{cycles}")
        
        # Simular decisão Darwin
        promote = cycle % 2 == 1  # Alternar decisões
        neuron_id = f"test_neuron_{cycle:03d}"
        reason = "darwin_promote" if promote else "darwin_maintain"
        
        print(f"   Darwin decide: {'PROMOVER' if promote else 'MANTER'}")
        
        # Executar spawn
        if spawn(neuron_id, reason):
            success_count += 1
            print(f"   ✅ Ciclo {cycle} bem-sucedido")
        else:
            fail_count += 1
            print(f"   ❌ Ciclo {cycle} falhou")
        
        # Pausa entre ciclos
        time.sleep(1)
    
    # Resumo final
    print(f"\n📊 RESUMO DO TESTE:")
    print(f"   Sucessos: {success_count}/{cycles}")
    print(f"   Falhas: {fail_count}/{cycles}")
    print(f"   Taxa de sucesso: {success_count/cycles*100:.1f}%")
    
    if success_count == cycles:
        print(f"🎉 TESTE COMPLETO BEM-SUCEDIDO!")
        return True
    else:
        print(f"⚠️ Alguns ciclos falharam, verificar logs")
        return False

if __name__ == "__main__":
    main()